/*
 *******************************************************************************
 *
 *   Copyright (C) 1999-2008, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *******************************************************************************
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
//#define UNIDEBUG
#include "unicode/utypes.h"
#include "unicode/ubidi.h"
#include "unicode/uscript.h"
#include "unicode/ctest.h"

#include "layout/LETypes.h"
#include "layout/LEScripts.h"
#include "layout/loengine.h"

#include "layout/playout.h"
#include "layout/plruns.h"

#include "cfonts.h"

#include "letest.h"

#include "sfnt.h"
#include "xmlreader.h"
#include "putilimp.h" /* for U_FILE_SEP_STRING */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define MAX_GLYPHS 100

#define CH_COMMA 0x002C
#define IMAGESIZE	24
char filename[100];

#define ENGLISH_LANGUAGE	0
#define HINDI_LANGUAGE		1
#define TELUGU_LANGUAGE		2
#define KANNADA_LANGUAGE	3
#define TAMIL_LANGUAGE		4
#define MALAYALAM_LANGUAGE	5

#define TELUGU_SCRIPT		36
#define KANNADA_SCRIPT		21
#define HINDI_SCRIPT		10
#define TAMIL_SCRIPT		35
#define MALAYALAM_SCRIPT	26
#define ENGLISH_SCRIPT		0

#define TELUGU_LANGCODE			24
#define KANNADA_LANGCODE		10
#define HINDI_LANGCODE			6
#define TAMIL_LANGCODE			23
#define MALAYALAM_LANGCODE		14
#define ENGLISH_LANGCODE		0

#define BMP_CREATION
//#define FONT_PATH	"/usr/fonts/"
#define FONT_PATH "./"
int FileId;
//static char FontFile[][30]={"gautami.ttf","tunga.ttf","mangal.ttf","latha.ttf","ARIALUNI.TTF","ARIALUNI.TTF"};
//static char FontFile[][30]={"akshar.ttf","akshar.ttf","akshar.ttf","latha.ttf","ARIALUNI.TTF","ARIALUNI.TTF"};
static char FontFile[][30]={FONT_PATH"ARIALUNI.TTF",FONT_PATH"ARIALUNI.TTF",FONT_PATH"Gidugu.ttf",FONT_PATH"ARIALUNI.TTF",FONT_PATH"ARIALUNI.TTF",FONT_PATH"ARIALUNI.TTF"};

static le_int32 iScriptCodes[]={ENGLISH_SCRIPT,HINDI_SCRIPT,TELUGU_SCRIPT,KANNADA_SCRIPT,TAMIL_SCRIPT,MALAYALAM_SCRIPT};
static le_int32 iLangCodes[]={ENGLISH_LANGCODE,HINDI_LANGCODE,TELUGU_LANGCODE,KANNADA_LANGCODE,TAMIL_LANGCODE,MALAYALAM_LANGCODE};

static le_font *openFont(const char *fontName)
{
    char path[2048];
    le_font *font;
    LEErrorCode fontStatus = LE_NO_ERROR;

	if (fontName != NULL) {
		font = le_portableFontOpen(fontName, 20, &fontStatus);

		if (LE_FAILURE(fontStatus)) {
			le_fontClose(font);
			return NULL;
		} else {

		}
	} else {
			log_info("Hello\n");
		font = le_simpleFontOpen(12, &fontStatus);
	}

    return font;
}

static le_bool getRTL(const LEUnicode *text, le_int32 charCount)
{
    UBiDiLevel level;
    le_int32 limit = -1;
    UErrorCode status = U_ZERO_ERROR;
    UBiDi *ubidi = ubidi_openSized(charCount, 0, &status);

    ubidi_setPara(ubidi, text, charCount, UBIDI_DEFAULT_LTR, NULL, &status);
    
    /* TODO: Should check that there's only a single logical run... */
    ubidi_getLogicalRun(ubidi, 0, &limit, &level);

    ubidi_close(ubidi);

    return level & 1;
}
/* example1.c                                                      */
/*                                                                 */
/* This small program shows how to print a rotated string with the */
/* FreeType 2 library.                                             */


#include <stdio.h>
#include <string.h>
#include <math.h>

#include <ft2build.h>
#include <freetype/ftimage.h>
#include <freetype/fttypes.h>
#include <freetype/freetype.h>
#include <freetype/ftautoh.h>
#include<freetype/ftglyph.h>


#define WIDTH   576
#define HEIGHT  1200
/* origin is the upper left corner */
unsigned char image[HEIGHT][WIDTH];
//unsigned char PrintBuffer[HEIGHT][WIDTH/8];
unsigned char PrintBuffer[HEIGHT*WIDTH/8];
#ifdef BMP_CREATION
unsigned char BMPimage[HEIGHT*WIDTH*3+54];
#endif
#pragma pack(1)
typedef struct FILEHEADER{
	unsigned short type;	/* Magic identifier            */
	unsigned int size;	/* File size in bytes          */
	unsigned short reserved1,reserved2;
	unsigned int offset;	/* Offset to image data, bytes */
}HEADER;

#pragma pack(1)
typedef struct {
	unsigned int size;	/* Header size in bytes      */
	int width, height;	/* Width and height of image */
	unsigned short int planes;	/* Number of colour planes   */
	unsigned short int bits;	/* Bits per pixel            */
	unsigned int compression;	/* Compression type          */
	unsigned int imagesize;	/* Image size in bytes       */
	int xresolution, yresolution;	/* Pixels per meter          */
	unsigned int ncolours;	/* Number of colours         */
	unsigned int importantcolours;	/* Important colours         */
}INFOHEADER;
HEADER Header;
INFOHEADER InfoHeader;
/* Replace this function with something useful. */
int flag=0;
int x_add=0;
#define SUCCESS 1
#define FAILURE 0
//unsigned char _UnicodeDataPrint(int height,unsigned char *PrintBuf);
//unsigned char ucUnicodePrint(void);
#ifdef BMP_CREATION
void BmpToBuffer(char *pcFileName)
{
	int iRetVal=0;
	unsigned char b[40];
	int fptr,j,k,l,count;
	unsigned char *pcBuffer=NULL,*pcLineBuffer=NULL;
#ifdef BMPEXT_DEBUG
	int i;
	unsigned char OneByte;
#endif

	fptr = open(pcFileName, O_RDONLY);
	if (fptr < 0)
	{
#ifdef BMPEXT_DEBUG	
		printf("Unable to open BMP file \"%s\"\n", FileName);
#endif
		return FAILURE;
	}	

	iRetVal = read(fptr, b, 14);
	if((iRetVal <= 0) && (iRetVal != 14))
	{
#ifdef BMPEXT_DEBUG		
		printf("Unable to read BMP file \"%s\"\n", FileName);
#endif
		close(fptr);
		return FAILURE;
	}
	memcpy(&Header.type,b,2);	
	memcpy(&Header.size,&b[2],4);	
	memcpy(&Header.reserved1,&b[6],2);	
	memcpy(&Header.reserved2,&b[8],2);	
	memcpy(&Header.offset,&b[10],4);	

	
	if(19778 != Header.type)
	{
#ifdef BMPEXT_DEBUG	
		printf("Incompatible file type\n");
#endif
		close(fptr);
		return FAILURE;
	}
	if((iRetVal = lseek(fptr, 1, SEEK_SET)) <= 0)
	{
#ifdef BMPEXT_DEBUG	
		printf("Seek Failed\n");
#endif
		close(fptr);
		return FAILURE;
	}
#ifdef BMPEXT_DEBUG	
	for(i=0; i< Header.size-1; i++)
	{
		iRetVal = read(fptr, &OneByte, 1);
		if(iRetVal != 1 )
		{
			printf("\n");
			close(fptr);
			return FAILURE;
		}
		printf("%-4X",OneByte);
		if((i+1)%20 == 0)
			printf("\n");
	}
	printf("\n");
	printf("Size of file header   \t\t= %d\n",sizeof(HEADER));
	printf("Magic Identifier \t\t= %d\n",Header.type);
	printf("File size in bytes \t\t= %d\n",Header.size);
	printf("Offset to image data, bytes \t= %d\n",Header.offset);
#endif	

	if((iRetVal = lseek(fptr, 14,SEEK_SET)) <= 0)
	{
#ifdef BMPEXT_DEBUG	
		printf("Seek Failed\n");
#endif
		close(fptr);
		return FAILURE;
	}
	iRetVal = read(fptr, b, 40);
	if(iRetVal <= 0)
	{
#ifdef BMPEXT_DEBUG	
		printf("Unable to read BMP file \"%s\"\n", FileName);
#endif
		close(fptr);
		return FAILURE;
	}
	memcpy(&InfoHeader.size,b,4);
	memcpy(&InfoHeader.width,&b[4],4);
	memcpy(&InfoHeader.height,&b[8],4);
	memcpy(&InfoHeader.planes,&b[12],2);
	memcpy(&InfoHeader.bits,&b[14],2);
	memcpy(&InfoHeader.compression,&b[16],4);
	memcpy(&InfoHeader.imagesize,&b[20],4);
	memcpy(&InfoHeader.xresolution,&b[24],4);
	memcpy(&InfoHeader.yresolution,&b[28],4);
	memcpy(&InfoHeader.ncolours,&b[32],4);
	memcpy(&InfoHeader.importantcolours,&b[36],4);

#ifdef BMPEXT_DEBUG	
	printf("BMP header size in bytes \t= %d\n",InfoHeader.size);
	printf("Width and height of image \t= %d,%d\n",InfoHeader.width,InfoHeader.height);
	printf("Number of colour planes \t= %d\n",InfoHeader.planes);
	printf("Bits per pixel \t\t\t= %d\n",InfoHeader.bits);
	printf("Compression type \t\t= %d\n",InfoHeader.compression);
	printf("Image size in bytes \t\t= %d\n",InfoHeader.imagesize);
	printf("Pixels per meter \t\t= %d,%d\n",InfoHeader.xresolution,InfoHeader.yresolution);
	printf("Number of colours \t\t= %d\n",InfoHeader.ncolours);
	printf("Important colours \t\t= %d\n",InfoHeader.importantcolours);	
#endif
	if(InfoHeader.height%2 || InfoHeader.width != WIDTH)
	{
		return FAILURE;
	}
	printf("\n before alloc");
	pcBuffer = (unsigned char *)malloc(WIDTH/8 * InfoHeader.height);
	if(pcBuffer == NULL)
	{
		return FAILURE;
	}
	
	pcLineBuffer = (unsigned char *)malloc(WIDTH * 3);
	if(pcBuffer == NULL)
	{
		free(pcBuffer);
		return FAILURE;
	}
	for (j=InfoHeader.height-1;j>0;j--)
	{
		iRetVal = read(fptr, pcLineBuffer, WIDTH*3);
		if(iRetVal <= 0)
		{
#ifdef BMPEXT_DEBUG	
			printf("Unable to read BMP file \"%s\"\n", FileName);
#endif
			free (pcBuffer);
			free (pcLineBuffer);
			close(fptr);
			return FAILURE;
		}
		l=0;
		count=8;
		for (k=0;k<WIDTH*3;k+=3)
		{
			count--;
			if((pcLineBuffer[k]^0xFF)>100)
			{
				pcBuffer[j*(WIDTH/8)+l] |= 1<<count;
			}
			if(count==0)
			{
				count=8;
				l++;
			}
			
		}
	}
}
#endif
void draw_bitmap_wrap( FT_Bitmap*  bitmap, FT_Int x,FT_Int  x_max, FT_Int  y,FT_Int  y_max)
{
  FT_Int  i, j, p, q;

  //printf("After x: %d y: %d x_max: %d y_max: %d\n",x,y,x_max,y_max);
  for ( i = x, p = 0; i < x_max; i++, p++ )
  {
    for ( j = y, q = 0; j < y_max; j++, q++ )
    {
      if ( i < 0      || j < 0       ||
           i >= WIDTH || j >= HEIGHT )
        continue;

      image[j][i] |= bitmap->buffer[q * bitmap->width + p];
    }
  }
}
void draw_bitmap( FT_Bitmap*  bitmap, FT_Int x, FT_Int  y)
{
  FT_Int  i, j, p, q;
  FT_Int  x_max = x + bitmap->width;
  FT_Int  y_max = y + bitmap->rows;
  #if 0

  #endif
  //printf("After x: %d y: %d x_max: %d y_max: %d\n",x,y,x_max,y_max);
  for ( i = x, p = 0; i < x_max; i++, p++ )
  {
    for ( j = y, q = 0; j < y_max; j++, q++ )
    {
      if ( i < 0      || j < 0       ||
           i >= WIDTH || j >= HEIGHT )
        continue;

      image[j][i] |= bitmap->buffer[q * bitmap->width + p];
    }
  }
}

int TrimBuffer(void)
{
	int i;
	unsigned char cmpBuffer[WIDTH];

	memset(cmpBuffer,0,WIDTH);

	for (i=HEIGHT-1; i>=0; i-- )
	{
		if (memcmp(image[i],cmpBuffer,WIDTH))
			break;
	}

	return i+1;
}
void ConvertBuffer(void)
{
	int i,j,k=0,count=8;
	int height;
	
	memset(PrintBuffer,0,sizeof PrintBuffer);
	height = TrimBuffer();
	for (i=0;i<height;i++)
	{
		k=0;
		for(j=0;j<WIDTH;j++)
		{
			count--;
			if(image[height-i-1][j]>100)
			{
				//PrintBuffer[i][k] |= 1<<count;
				PrintBuffer[i*(WIDTH/8) +k] |= 1<<count;
			}
			if(count==0)
			{
				count=8;
				k++;
			}
		}
	}
#ifdef UNIDEBUG
	//printf ("ucUnicodePrint: %02X\n",ucUnicodePrint());
	//printf ("_UnicodeDataPrint: %02X\n",_UnicodeDataPrint(height, PrintBuffer));
#else
	//ucUnicodePrint();
	//_UnicodeDataPrint(height, PrintBuffer);
#endif
	//_UnicodeDataPrint(height, PrintBuffer);
}

#ifdef BMP_CREATION
void
show_image( void )
{
  int  i, j,tmp=0,k=54,fd;
  unsigned char *bmp_infoheader=BMPimage+14;
  unsigned short int tmp_short;
	BMPimage[0]='B';
	BMPimage[1]='M';
	tmp = 14 + 40 + WIDTH* HEIGHT*3 ;
	memcpy((BMPimage+2), &tmp, 4);
	/* 0 */
	tmp = 0;
	memcpy((BMPimage+6), &tmp, 4);
	/* Offset value */
	tmp = 14 + 40;
	memcpy((BMPimage+10), &tmp, 4);

	/* 40 */
	tmp = 40;
	memcpy(bmp_infoheader, &tmp, 4);
	/* Width */
	tmp = WIDTH;
	memcpy(bmp_infoheader + 4, &tmp, 4);
	/* Height */
	tmp = HEIGHT;
	memcpy(bmp_infoheader + 8, &tmp, 4);
	/* 1 */
	tmp_short = 1;   
	memcpy(bmp_infoheader + 12, &tmp_short, 2);
	/* bpp */
	tmp_short = 24;
	memcpy(bmp_infoheader + 14, &tmp_short, 2);
	/* 0 = nessuna compressione */
	tmp = 0;
	memcpy(bmp_infoheader + 16, &tmp, 4);
	memcpy(bmp_infoheader + 20, &tmp, 4);
	memcpy(bmp_infoheader + 24, &tmp, 4);
	memcpy(bmp_infoheader + 28, &tmp, 4);
	memcpy(bmp_infoheader + 32, &tmp, 4);
	memcpy(bmp_infoheader + 36, &tmp, 4);

  for ( i = 0; i < HEIGHT; i++ )
  {
    for ( j = 0; j < WIDTH; j++ )
    {
    	/*
      //putchar( image[i][j] == 0 ? ' '
        //                        : image[i][j] < 128 ? ' '
          //                                          : '@' );
         if(image[i][j] == 0) 
         {
			
		 }
		 else
		 {
			
		 }*/
		 BMPimage[k++] = image[i][j]^0xFF;
		 BMPimage[k++] = image[i][j]^0xFF;
		 BMPimage[k++] = image[i][j]^0xFF;
    }
    //putchar( '\n' );
  }
  //system("rm -f Test.bmp");
  //system("touch Test.bmp");
  sprintf(filename,"rm -f Test%d.bmp",FileId);
  system(filename);
  sprintf(filename,"touch Test%d.bmp",FileId);
  system(filename);
  sprintf(filename,"Test%d.bmp",FileId);
  fd = open(filename,O_RDWR);
  if(fd>0)
  {
  	write(fd,BMPimage,54);
	for(i=HEIGHT-1;i>=0;i--)
	{
		write(fd,BMPimage+(i*WIDTH*3)+54,WIDTH*3);	
	}
	close(fd);
  }
  else
  {
	printf("File open failed\n");
  }
  FileId++;
}
#endif
FT_Glyph      glyphs[MAX_GLYPHS];   /* glyph image    */    
int glyphcount;
void  compute_string_bbox( FT_BBox  *abbox )
  {
    FT_BBox  bbox;
	int n;
	int num_glyphs=glyphcount;
	FT_Vector     pos   [MAX_GLYPHS];
    /* initialize string bbox to "empty" values */    
    bbox.xMin = bbox.yMin =  32000;
    bbox.xMax = bbox.yMax = -32000;

    /* for each glyph image, compute its bounding box, */    
    /* translate it, and grow the string bbox          */    
    for ( n = 0; n < num_glyphs; n++ )
    {
      FT_BBox  glyph_bbox;


      FT_Glyph_Get_CBox( glyphs[n], ft_glyph_bbox_pixels,
                         &glyph_bbox );

      glyph_bbox.xMin += pos[n].x;
      glyph_bbox.xMax += pos[n].x;
      glyph_bbox.yMin += pos[n].y;
      glyph_bbox.yMax += pos[n].y;

      if ( glyph_bbox.xMin < bbox.xMin )
        bbox.xMin = glyph_bbox.xMin;

      if ( glyph_bbox.yMin < bbox.yMin )
        bbox.yMin = glyph_bbox.yMin;

      if ( glyph_bbox.xMax > bbox.xMax )
        bbox.xMax = glyph_bbox.xMax;

      if ( glyph_bbox.yMax > bbox.yMax )
        bbox.yMax = glyph_bbox.yMax;
    }

    /* check that we really grew the string bbox */    
    if ( bbox.xMin > bbox.xMax )
    {
      bbox.xMin = 0;
      bbox.yMin = 0;
      bbox.xMax = 0;
      bbox.yMax = 0;
    }

    /* return string bbox */    
        *abbox = bbox;
  }
      
int
Printmain(char *filename,FT_UInt* myIndex, int len)
{
  FT_UInt       glyph_index;
  FT_Bool       use_kerning;
  FT_UInt       previous;

  FT_Vector     pos   [MAX_GLYPHS];   /* glyph position */    
  FT_UInt       num_glyphs;
  FT_Library    library;
  FT_Face       face;

  FT_GlyphSlot  slot;
  FT_Matrix     matrix;                 /* transformation matrix */
  FT_Vector     pen;                    /* untransformed origin  */
  FT_Error      error;
	FT_Bitmap*  bitmap;
	FT_Int x,y,x_max,y_max;
	int ret;
  double        angle;
  int           target_height;
  int           n, num_chars;
  FT_UInt Space=0;
  int iWordWidth[100],iWordCount=0,left=0,right=0,count=1;
//FT_UInt myIndex[10]={0x126, 0x116, 0x138, 0x9C, 0x03, 0x62,0x33, 0x43, 0x23B, 0xFFFF},ret; //Gowree in gauthami
//FT_UInt myIndex[10]={0x20C, 0xFFFF, 0x198, 0xFFFF, 0x1F5, 0xFFFF, 0x13A, 0x66, 0x242, 0xFFFF},ret; // Srinivas in gauthami
//FT_UInt myIndex[10]={0x77A, 0x780, 0x775, 0x78B, 0x76E, 0x77F, 0x779, 0x77E, 0x77C, 0x78B},ret; // Srinivas in arial
//FT_UInt myIndex[10]={0x30C, 0xFFFF, 0x270, 0xFFFF, 0x04, 0xA5, 0x76, 0x86, 0x348, 0xFFFE},ret; // Gowree in tenali
FT_ULong Index[11]={0xC17,0x0C4C,0xC30,0xc40,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
//FT_ULong Index[11]={0xC85,0xCA8,0xCC2,0xCB7};//,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
FT_UInt sub_index=0,p_flags;
FT_Int p_index,p_arg2,p_arg1;
FT_Matrix    p_transform;
FT_Vector  start;
FT_BBox string_bbox;
  FT_Matrix  transform;
	  int rem=0,dev_x=0,dev_x_max=0,prev_width;

  angle         = 0;//( 25.0 / 360 ) * 3.14159 * 2;      /* use 25 degrees     */
  target_height = HEIGHT;
  num_chars = len;

	int pen_x=3,pen_y=20;
	memset(image,0,HEIGHT*WIDTH);
	x_add=0;

  FT_Prop_GlyphToScriptMap  prop;
FT_UInt     fallback_script = FT_AUTOHINTER_SCRIPT_INDIC;
  error = FT_Init_FreeType( &library );              /* initialize library */
  /* error handling omitted */
  error = FT_New_Face( library, filename, 0, &face );/* create face object */
  printf ("error: %d\n",error);
  face->max_advance_width=WIDTH;
  face->max_advance_height=HEIGHT;
prop.face = face;
FT_Property_Get( library, "autofitter",
                            "glyph-to-script-map", &prop ); 
FT_Property_Set( library, "autofitter",
                            "fallback-script", &fallback_script );
 /* error handling omitted */
  FT_Select_Charmap(face,FT_ENCODING_UNICODE);
  /* use 50pt at 100dpi */
  error = FT_Set_Char_Size( face, IMAGESIZE*64, 0,
                            100, 0 );                /* set character size */
  /* error handling omitted */

  slot = face->glyph;

  /* set up matrix */
  matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
  matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
  matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
  matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

  /* the pen position in 26.6 cartesian space coordinates; */
  /* start at (300,200) relative to the upper left corner  */
  pen.x = 0;//3 * 64;
  pen.y = ( target_height - IMAGESIZE-10) * 64;

	pen_x = 0;   /* start at (0,0) */    
  pen_y = 0;

#if 0
  num_glyphs  = 0;
  use_kerning = FT_HAS_KERNING( face );
  previous    = 0;
glyphcount = num_chars;
  for ( n = 0; n < num_chars; n++ )
  {
    /* convert character code to glyph index */    
    glyph_index = myIndex[n];//FT_Get_Char_Index( face, text[n] );

    /* retrieve kerning distance and move pen position */    
    if ( use_kerning && previous && glyph_index )
    {
      FT_Vector  delta;


      FT_Get_Kerning( face, previous, glyph_index,
                      FT_KERNING_DEFAULT, &delta );

      pen_x += delta.x >> 6;
    }

    /* store current pen position */    
    pos[num_glyphs].x = pen_x;
    pos[num_glyphs].y = pen_y;

    /* load glyph image into the slot without rendering */    
    error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
    if ( error )
      continue;  /* ignore errors, jump to next glyph */    

    /* extract glyph image and store it in our table */    
    error = FT_Get_Glyph( face->glyph, &glyphs[num_glyphs] );
    if ( error )
      continue;  /* ignore errors, jump to next glyph */    
	
    /* increment pen position */    
    pen_x += slot->advance.x >> 6;

    /* record current glyph index */    
    previous = glyph_index;

    /* increment number of glyphs */    
    num_glyphs++;
  }
   /* get bbox of original glyph sequence */    
  compute_string_bbox( &string_bbox );
   int string_width,start_x,start_y;
   int string_height,my_target_height=HEIGHT;
   /* compute string dimensions in integer pixels */    
  string_width  = string_bbox.xMax - string_bbox.xMin;
  string_height = string_bbox.yMax - string_bbox.yMin;

  /* compute start pen position in 26.6 cartesian pixels */    
  start_x = ( ( WIDTH- string_width  ) / 2 ) * 64;
  start_y = ( ( my_target_height - string_height ) / 2 ) * 64;

  for ( n = 0; n < num_glyphs; n++ )
  {
    FT_Glyph   image;
    FT_Vector  pen;


    image = glyphs[n];

    pen.x = start_x + pos[n].x;
    pen.y = start_y + pos[n].y;

    error = FT_Glyph_To_Bitmap( &image, FT_RENDER_MODE_MONO,
                                &pen, 0 );
    if ( !error )
    {
      FT_BitmapGlyph  bit = (FT_BitmapGlyph)image;


      draw_bitmap( bit->bitmap,
                      bit->left,
                      my_target_height - bit->top );

      FT_Done_Glyph( image );
    }
  }
#else
	use_kerning = FT_HAS_KERNING( face );
	previous    = 0;
	Space = FT_Get_Char_Index(face, ' ');
#if 1
  bitmap = &slot->bitmap;

  for ( n = 0; n < num_chars; n++ )
  {
    /* set transformation */
    FT_Set_Transform( face, &matrix, &pen );
    //FT_Get_Next_Char(face,Index[n],&ret);
    error = FT_Load_Glyph( face, myIndex[n], FT_LOAD_RENDER | FT_KERNING_DEFAULT);
    //error = FT_Load_Char( face, Index[n], FT_LOAD_RENDER );
    if ( error )
      continue;
	if(n>0 && myIndex[n-1] == Space)
    {
		iWordWidth[iWordCount++]=  right-left;
#ifdef UNIDEBUG
		printf("Word Count: %d Word Width: %d left: %d right: %d\n",iWordCount-1,iWordWidth[iWordCount-1],left,right);
#endif
    	left = slot->bitmap_left;
		//printf("slot->bitmap_left: %d bitmap->width:%d\n",slot->bitmap_left, bitmap->width);
		//prev_width = slot->bitmap_left;
	}
    if(n>0 && slot->bitmap_left>0)
		right = slot->bitmap_left + bitmap->width;
    /* increment pen position */
    pen.x += slot->advance.x;
    pen.y += slot->advance.y;
//	pen_x += slot->advance.x >> 6;
	previous = ret;
//	right = slot->bitmap_left;
  }
	iWordWidth[iWordCount++]=  right-left;
#ifdef UNIDEBUG
	printf("Word Count: %d Word Width: %d left: %d right: %d\n",iWordCount-1,iWordWidth[iWordCount-1],left,right);
#endif
  /* the pen position in 26.6 cartesian space coordinates; */
  /* start at (300,200) relative to the upper left corner  */
  pen.x = 0;//2 * 64;
  pen.y = ( target_height - IMAGESIZE-10) * 64;

	pen_x = 0;   /* start at (0,0) */    
  pen_y = 0;
  FT_Set_Transform( face, &matrix, &pen );
  for ( n = 0; n < num_chars; n++ )
  {

    /* set transformation */
    FT_Set_Transform( face, &matrix, &pen );
    //FT_Get_Next_Char(face,Index[n],&ret);
    error = FT_Load_Glyph( face, myIndex[n], FT_LOAD_RENDER | FT_KERNING_DEFAULT);
    //error = FT_Load_Char( face, Index[n], FT_LOAD_RENDER );
    if ( error )
      continue;
	  x = slot->bitmap_left;
	  x_max = slot->bitmap_left + bitmap->width;
	  y = target_height - slot->bitmap_top;
	  y_max= y+bitmap->rows;
	  //printf("Before x: %d y: %d x_max: %d y_max: %d\n",x,y,x_max,y_max);
	  if(x!=x_max && y!=y_max)
	  {
		  x +=x_add;
		  x_max +=x_add;
		  //printf("After x: %d y: %d x_max: %d y_max: %d\n",x,y,x_max,y_max);
		  dev_x = x/WIDTH;
		  dev_x_max = x_max/WIDTH;
		  
		  if(dev_x_max)
		  {
		  	if((dev_x==dev_x_max))
		  	{
				x=x%WIDTH;
				x_max=x_max%WIDTH;
				y=y+((IMAGESIZE+15)*dev_x);
				y_max=y_max+((IMAGESIZE+15)*dev_x);
		  	}
			else
			{
#ifdef UNIDEBUG
		  		printf("1iWord: %d count:%d\n",iWordWidth[count],count);
#endif
				x_add += (WIDTH - x%WIDTH);
				x_max=x_max-x;
				x=0;
				y=y+((IMAGESIZE+15)*dev_x_max);
				y_max=y_max+((IMAGESIZE+15)*dev_x_max);
			}
		  }
		  if(n>0)
		  {
			  if(Space == myIndex[n-1])
			  {
#ifdef UNIDEBUG
		  		printf("iWord: %d count:%d\n",iWordWidth[count],count);
#endif
				if((iWordWidth[count]>WIDTH) || (x + iWordWidth[count]>WIDTH))
			  	{
					x_add += WIDTH-x;//x;
					x_max -= x;
					x=0;
					y=y+((IMAGESIZE+15));
					y_max=y_max+((IMAGESIZE+15));
					
				}
				/*
			  	else if(x + iWordWidth[count]>WIDTH)
			  	{
					x_add += WIDTH-x;
					x_max -= x;
					x=0;
					y=y+((IMAGESIZE+15));
					y_max=y_max+((IMAGESIZE+15));
				}*/
			  	++count;
			  }
		  }
#ifdef UNIDEBUG
		  printf("Resize x: %d y: %d x_max: %d y_max: %d x_add: %d\n",x,y,x_max,y_max,x_add);
#endif		  
		  if(x==0 )
		  {
			x=2;
			x_max +=2;
			x_add +=2;
		  }
		  if(y_max>HEIGHT && (x!=x_max && y!=y_max))
		  {
			printf ("Out of memory\n");
			break;
		  }
	  }
                 /* ignore errors */
    //FT_Render_Glyph( face->glyph, FT_RENDER_MODE_NORMAL);
	/* now, draw to our target surface (convert position) */
    /*draw_bitmap( &slot->bitmap,
                 slot->bitmap_left,
                 target_height - slot->bitmap_top );*/
    draw_bitmap_wrap( &slot->bitmap,x,x_max,y,y_max );
	
    /* increment pen position */
    pen.x += slot->advance.x;
    pen.y += slot->advance.y;
//	pen_x += slot->advance.x >> 6;
	previous = ret;
  }
#endif

#endif
#ifdef BMP_CREATION
	show_image();
#else
	ConvertBuffer();
#endif

  FT_Done_Face    ( face );
  FT_Done_FreeType( library );

  return 0;
}
int
Printmain2(char *filename,FT_UInt* myIndex, int len)
{
  FT_Library    library;
  FT_Face       face;

  FT_GlyphSlot  slot;
  FT_Matrix     matrix;                 /* transformation matrix */
  FT_Vector     pen;                    /* untransformed origin  */
  FT_Error      error;

	int ret;
  double        angle;
  int           target_height;
  int           n, num_chars;
  
//FT_UInt myIndex[10]={0x126, 0x116, 0x138, 0x9C, 0x03, 0x62,0x33, 0x43, 0x23B, 0xFFFF},ret; //Gowree in gauthami
//FT_UInt myIndex[10]={0x20C, 0xFFFF, 0x198, 0xFFFF, 0x1F5, 0xFFFF, 0x13A, 0x66, 0x242, 0xFFFF},ret; // Srinivas in gauthami
//FT_UInt myIndex[10]={0x77A, 0x780, 0x775, 0x78B, 0x76E, 0x77F, 0x779, 0x77E, 0x77C, 0x78B},ret; // Srinivas in arial
//FT_UInt myIndex[10]={0x30C, 0xFFFF, 0x270, 0xFFFF, 0x04, 0xA5, 0x76, 0x86, 0x348, 0xFFFE},ret; // Gowree in tenali
FT_ULong Index[11]={0xC17,0x0C4C,0xC30,0xc40,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
//FT_ULong Index[11]={0xC85,0xCA8,0xCC2,0xCB7};//,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
FT_UInt sub_index=0,p_flags;
FT_Int p_index,p_arg2,p_arg1;
FT_Matrix    p_transform;


  angle         = 0;//( 25.0 / 360 ) * 3.14159 * 2;      /* use 25 degrees     */
  target_height = HEIGHT;
  num_chars = len;

	int previous=0,use_kerning,pen_x=3,pen_y=20;

  FT_Prop_GlyphToScriptMap  prop;
FT_UInt     fallback_script = FT_AUTOHINTER_SCRIPT_INDIC;
  error = FT_Init_FreeType( &library );              /* initialize library */
  /* error handling omitted */

  error = FT_New_Face( library, filename, 0, &face );/* create face object */
  face->max_advance_width=WIDTH;
  face->max_advance_height=HEIGHT;
prop.face = face;
FT_Property_Get( library, "autofitter",
                            "glyph-to-script-map", &prop ); 
FT_Property_Set( library, "autofitter",
                            "fallback-script", &fallback_script );
 /* error handling omitted */
  FT_Select_Charmap(face,FT_ENCODING_UNICODE);
  /* use 50pt at 100dpi */
  error = FT_Set_Char_Size( face, IMAGESIZE*64, 0,
                            100, 0 );                /* set character size */
  /* error handling omitted */

  slot = face->glyph;

  /* set up matrix */
  matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
  matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
  matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
  matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

  /* the pen position in 26.6 cartesian space coordinates; */
  /* start at (300,200) relative to the upper left corner  */
  pen.x = 3 * 64;
  pen.y = ( target_height - 60 ) * 64;

	use_kerning = FT_HAS_KERNING( face );
	previous    = 0;

#if 1
  for ( n = 0; n < num_chars; n++ )
  //for ( n = 0; n <3; n++ )
  //for ( n = 0; n < face->num_glyphs; n++ )
  {
    /* set transformation */
    FT_Set_Transform( face, &matrix, &pen );
#if 0	
    FT_Select_Charmap(face,FT_ENCODING_ADOBE_STANDARD);
    /* load glyph image into the slot (erase previous one) */
    //error = FT_Load_Char( face, text[n], FT_LOAD_RENDER );
    ret = FT_Get_Char_Index(face, Index[n]);
    if(!ret)
	continue;
    // if ( use_kerning && previous && ret )
    {
      FT_Vector  delta;


      FT_Get_Kerning( face, previous, ret,
                      FT_KERNING_DEFAULT , &delta );

  //    pen_x += delta.x >> 6;
    }

#endif
    //FT_Get_Next_Char(face,Index[n],&ret);
    error = FT_Load_Glyph( face, myIndex[n], FT_LOAD_RENDER | FT_KERNING_DEFAULT);
    //error = FT_Load_Char( face, Index[n], FT_LOAD_RENDER );
    if ( error )
      continue;
	//printf ("max_advance_width: %d max_advance_height: %d\n",face->max_advance_width,face->max_advance_height);
                 /* ignore errors */
    //FT_Render_Glyph( face->glyph, FT_RENDER_MODE_NORMAL);
	/* now, draw to our target surface (convert position) */
    draw_bitmap( &slot->bitmap,
                 slot->bitmap_left,
                 target_height - slot->bitmap_top );

    /* increment pen position */
	//printf("slot->advance.x: %d slot->advance.y: %d\n",slot->advance.x,slot->advance.y);
    pen.x += slot->advance.x;
    pen.y += slot->advance.y;
//	pen_x += slot->advance.x >> 6;
	previous = ret;
  }
#endif
#ifdef BMP_CREATION
  show_image();
#endif

  FT_Done_Face    ( face );
  FT_Done_FreeType( library );

  return 0;
}

int
Printmain1(char *filename,FT_UInt* myIndex, int len)
{
  FT_Library    library;
  FT_Face       face;

  FT_GlyphSlot  slot;
  FT_Matrix     matrix;                 /* transformation matrix */
  FT_Vector     pen;                    /* untransformed origin  */
  FT_Error      error;

	int ret;
  double        angle;
  int           target_height;
  int           n, num_chars;
  
//FT_UInt myIndex[10]={0x126, 0x116, 0x138, 0x9C, 0x03, 0x62,0x33, 0x43, 0x23B, 0xFFFF},ret; //Gowree in gauthami
//FT_UInt myIndex[10]={0x20C, 0xFFFF, 0x198, 0xFFFF, 0x1F5, 0xFFFF, 0x13A, 0x66, 0x242, 0xFFFF},ret; // Srinivas in gauthami
//FT_UInt myIndex[10]={0x77A, 0x780, 0x775, 0x78B, 0x76E, 0x77F, 0x779, 0x77E, 0x77C, 0x78B},ret; // Srinivas in arial
//FT_UInt myIndex[10]={0x30C, 0xFFFF, 0x270, 0xFFFF, 0x04, 0xA5, 0x76, 0x86, 0x348, 0xFFFE},ret; // Gowree in tenali
FT_ULong Index[11]={0xC17,0x0C4C,0xC30,0xc40,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
//FT_ULong Index[11]={0xC85,0xCA8,0xCC2,0xCB7};//,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
FT_UInt sub_index=0,p_flags;
FT_Int p_index,p_arg2,p_arg1;
FT_Matrix    p_transform;


  angle         = 0;//( 25.0 / 360 ) * 3.14159 * 2;      /* use 25 degrees     */
  target_height = HEIGHT;
  num_chars = len;

	int previous=0,use_kerning,pen_x=3,pen_y=20;

  FT_Prop_GlyphToScriptMap  prop;
FT_UInt     fallback_script = FT_AUTOHINTER_SCRIPT_INDIC;
  error = FT_Init_FreeType( &library );              /* initialize library */
  /* error handling omitted */

  error = FT_New_Face( library, filename, 0, &face );/* create face object */
prop.face = face;
FT_Property_Get( library, "autofitter",
                            "glyph-to-script-map", &prop ); 
FT_Property_Set( library, "autofitter",
                            "fallback-script", &fallback_script );
 /* error handling omitted */
  FT_Select_Charmap(face,FT_ENCODING_UNICODE);
  /* use 50pt at 100dpi */
  error = FT_Set_Char_Size( face, 20*64, 0,
                            100, 0 );                /* set character size */
  /* error handling omitted */

  slot = face->glyph;

  /* set up matrix */
  matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
  matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
  matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
  matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );

  /* the pen position in 26.6 cartesian space coordinates; */
  /* start at (300,200) relative to the upper left corner  */
  pen.x = 3 * 64;
  pen.y = ( target_height - 30 ) * 64;

	use_kerning = FT_HAS_KERNING( face );
	previous    = 0;

#if 1
  for ( n = 0; n < num_chars; n++ )
  //for ( n = 0; n <3; n++ )
  //for ( n = 0; n < face->num_glyphs; n++ )
  {
    /* set transformation */
    FT_Set_Transform( face, &matrix, &pen );
    FT_Select_Charmap(face,FT_ENCODING_ADOBE_STANDARD);
    /* load glyph image into the slot (erase previous one) */
    //error = FT_Load_Char( face, text[n], FT_LOAD_RENDER );
    ret = FT_Get_Char_Index(face, myIndex[n]);
    if(!ret)
	continue;
    // if ( use_kerning && previous && ret )
    {
      FT_Vector  delta;


      FT_Get_Kerning( face, previous, ret,
                      FT_KERNING_DEFAULT , &delta );

  //    pen_x += delta.x >> 6;
    }


    //FT_Get_Next_Char(face,Index[n],&ret);
    error = FT_Load_Glyph( face, ret, FT_LOAD_RENDER);
    //error = FT_Load_Char( face, Index[n], FT_LOAD_RENDER );
    if ( error )
      continue;
                 /* ignore errors */
    FT_Render_Glyph( face->glyph, FT_RENDER_MODE_NORMAL);
	/* now, draw to our target surface (convert position) */
    draw_bitmap( &slot->bitmap,
                 slot->bitmap_left,
                 target_height - slot->bitmap_top );

    /* increment pen position */
    pen.x += slot->advance.x;
    pen.y += slot->advance.y;
//	pen_x += slot->advance.x >> 6;
	previous = ret;
  }
#endif
#ifdef BMP_CREATION
  show_image();
#endif

  FT_Done_Face    ( face );
  FT_Done_FreeType( library );

  return 0;
}
void FindChars(LEUnicode* uchars,int len,const char * fontName,int langcode)
{
	LEErrorCode status = LE_NO_ERROR;
	le_engine *engine;
	le_font *font = openFont(fontName);
	le_int32 typoFlags = 3; /* kerning + ligatures */
	TestResult actual;
	le_int32 scriptCode=iScriptCodes[langcode];
	le_int32 languageCode=iLangCodes[langcode];//24;
	le_int32 charCount;
	TestResult *expected;
	//LEUnicode uchars[]={0xC17,0x0C4C,0xC30,0xc40,0x20,0xc36,0xc02,0xc15,0xc30,0xc4d};
	//LEUnicode uchars[]={0x0C36, 0x0C4D, 0x0C30,  0x0C40, 0x0C28, 0x0C3F, 0x0C35, 0x0C3E, 0x0C38, 0x0C4D};
	//LEUnicode uchars[]={0x0CAE, 0x0CBE, 0x0CB2,  0x0CBE, 0x0CB6, 0x0CCD, 0x0CB0, 0x0CC0};
	//LEUnicode uchars[]={2327,2380,2352,2368};
	//LEUnicode uchars[]={0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,
		//				0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,
			//			0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD };
	//LEUnicode uchars[]={0x0047,0x006F,0x0077,0x0072,0x0065,0x0065,0x0020,0x0053,0x0061,0x006E,0x006B,0x0061,0x0072,0x0061,0x0020,0x0052,0x0061,0x006F,0x0020,0x004B,0x0075,0x0072,0x006D,0x0061,0x006E,0x0061,0x000D,0x000A,0x0C95,0x0CA8,0x0CCD,0x0CA8,0x0CA1,0x0020,0x0C24,0x0C46,0x0C32,0x0C41,0x0C17,0x0C41,0x0047,0x006F,0x0077,0x0072,0x0065,0x0065,0x0020,0x0053,0x0061,0x006E,0x006B,0x0061,0x0072,0x0061,0x0020,0x0052,0x0061,0x006F,0x0020,0x004B,0x0075,0x0072,0x006D,0x0061,0x006E,0x0061,0x000D,0x000A,0x0C95,0x0CA8,0x0CCD,0x0CA8,0x0CA1,0x0020,0x0C24,0x0C46,0x0C32,0x0C41,0x0C17,0x0C41,0x0047,0x006F,0x0077,0x0072,0x0065,0x0065,0x0020,0x0053,0x0061,0x006E,0x006B,0x0061,0x0072,0x0061,0x0020,0x0052,0x0061,0x006F,0x0020,0x004B,0x0075,0x0072,0x006D,0x0061,0x006E,0x0061,0x000D,0x000A,0x0C95,0x0CA8,0x0CCD,0x0CA8,0x0CA1,0x0020,0x0C24,0x0C46,0x0C32,0x0C41,0x0C17,0x0C41,0x0047,0x006F,0x0077,0x0072,0x0065,0x0065,0x0020,0x0053,0x0061,0x006E,0x006B,0x0061,0x0072,0x0061,0x0020,0x0052,0x0061,0x006F,0x0020,0x004B,0x0075,0x0072,0x006D,0x0061,0x006E,0x0061,0x000D,0x000A,0x0C95,0x0CA8,0x0CCD,0x0CA8,0x0CA1,0x0020,0x0C24,0x0C46,0x0C32,0x0C41,0x0C17,0x0C41,0x0047,0x006F,0x0077,0x0072,0x0065,0x0065,0x0020,0x0053,0x0061,0x006E,0x006B,0x0061,0x0072,0x0061,0x0020,0x0052,0x0061,0x006F,0x0020,0x004B,0x0075,0x0072,0x006D,0x0061,0x006E,0x0061,0x000D,0x000A,0x0C95,0x0CA8,0x0CCD,0x0CA8,0x0CA1,0x0020,0x0C24,0x0C46,0x0C32,0x0C41,0x0C17,0x0C41,0x0047,0x006F,0x0077,0x0072,0x0065,0x0065,0x0020,0x0053,0x0061,0x006E,0x006B,0x0061,0x0072,0x0061,0x0020,0x0052,0x0061,0x006F,0x0020,0x004B,0x0075,0x0072,0x006D,0x0061,0x006E,0x0061,0x000D,0x000A,0x0C95,0x0CA8,0x0CCD,0x0CA8,0x0CA1,0x0020,0x0C24,0x0C46,0x0C32,0x0C41,0x0C17,0x0C41};
	//LEUnicode uchars[]={0x0C0E,0x0C15,0x0C4D,0x0C15,0x0C21,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0020,0x0C2A,0x0C15,0x0C4D,0x0C15,0x0C28,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C47,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F,0x0020,0x0C1A,0x0C46,0x0C32,0x0C3F,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C05,0x0C32,0x0C4D,0x0C32,0x0C3E,0x0C30,0x0C40,0x000D,0x000A,0x0C28,0x0C3E,0x0020,0x0C28,0x0C40,0x0C26,0x0C48,0x0C28,0x0C3E,0x0020,0x0C06,0x0C15,0x0C4D,0x0C1A,0x0C02,0x0020,0x0C28,0x0C40,0x0C32,0x0C3E,0x0020,0x0C15,0x0C28,0x0C3F,0x0C2A,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C42,0x0020,0x0C09,0x0C02,0x0C26,0x0C3F,0x0020,0x0C05,0x0C30,0x0C46,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C17,0x0C3E,0x0C30,0x0C21,0x0C3F,0x0C08,0x000D,0x000A,0x0C28,0x0C47,0x0C28,0x0C41,0x0020,0x0C15,0x0C42,0x0C21,0x0C3E,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C3E,0x0C2F,0x0C3E,0x0C28,0x0C3E,0x0020,
	//0x0C0E,0x0C15,0x0C4D,0x0C15,0x0C21,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0020,0x0C2A,0x0C15,0x0C4D,0x0C15,0x0C28,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C47,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F,0x0020,0x0C1A,0x0C46,0x0C32,0x0C3F,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C05,0x0C32,0x0C4D,0x0C32,0x0C3E,0x0C30,0x0C40,0x000D,0x000A,0x0C28,0x0C3E,0x0020,0x0C28,0x0C40,0x0C26,0x0C48,0x0C28,0x0C3E,0x0020,0x0C06,0x0C15,0x0C4D,0x0C1A,0x0C02,0x0020,0x0C28,0x0C40,0x0C32,0x0C3E,0x0020,0x0C15,0x0C28,0x0C3F,0x0C2A,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C42,0x0020,0x0C09,0x0C02,0x0C26,0x0C3F,0x0020,0x0C05,0x0C30,0x0C46,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C17,0x0C3E,0x0C30,0x0C21,0x0C3F,0x0C08,0x000D,0x000A,0x0C28,0x0C47,0x0C28,0x0C41,0x0020,0x0C15,0x0C42,0x0C21,0x0C3E,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C3E,0x0C2F,0x0C3E,0x0C28,0x0C3E,0x0020,
	//0x0C0E,0x0C15,0x0C4D,0x0C15,0x0C21,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0020,0x0C2A,0x0C15,0x0C4D,0x0C15,0x0C28,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C47,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F,0x0020,0x0C1A,0x0C46,0x0C32,0x0C3F,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C05,0x0C32,0x0C4D,0x0C32,0x0C3E,0x0C30,0x0C40,0x000D,0x000A,0x0C28,0x0C3E,0x0020,0x0C28,0x0C40,0x0C26,0x0C48,0x0C28,0x0C3E,0x0020,0x0C06,0x0C15,0x0C4D,0x0C1A,0x0C02,0x0020,0x0C28,0x0C40,0x0C32,0x0C3E,0x0020,0x0C15,0x0C28,0x0C3F,0x0C2A,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C42,0x0020,0x0C09,0x0C02,0x0C26,0x0C3F,0x0020,0x0C05,0x0C30,0x0C46,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C17,0x0C3E,0x0C30,0x0C21,0x0C3F,0x0C08,0x000D,0x000A,0x0C28,0x0C47,0x0C28,0x0C41,0x0020,0x0C15,0x0C42,0x0C21,0x0C3E,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C3E,0x0C2F,0x0C3E,0x0C28,0x0C3E,0x0020};
	//LEUnicode uchars[]={0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F};
	int i;

	//charCount = sizeof (uchars)/sizeof (uchars[0]);
	charCount = len;
	if (font == NULL) {
		/* error message already printed. */
		return;
	}

	if (fontName == NULL) {
		typoFlags |= 0x80000000L;  /* use CharSubstitutionFilter... */
	}
   
    engine = le_create(font, scriptCode, languageCode, typoFlags, &status);

    if (LE_FAILURE(status)) {
        goto free_expected;
    }
    actual.glyphCount = le_layoutChars(engine, uchars, 0, charCount, charCount, getRTL(uchars, charCount), 0, 0, &status);

    actual.glyphs    = NEW_ARRAY(LEGlyphID, actual.glyphCount);
    actual.indices   = NEW_ARRAY(le_int32, actual.glyphCount);
    actual.positions = NEW_ARRAY(float, actual.glyphCount * 2 + 2);

    le_getGlyphs(engine, actual.glyphs, &status);
    le_getCharIndices(engine, actual.indices, &status);
    le_getGlyphPositions(engine, actual.positions, &status);
//    printf("actual.glyphCount: %d\n",actual.glyphCount);
#ifdef UNIDEBUG
    for(i=0;i<actual.glyphCount;i++)
	printf("0x%02X, ",actual.glyphs[i]);
	printf("\n");
#endif
	Printmain(fontName,actual.glyphs,actual.glyphCount);
	//Printmain1(fontName,uchars,charCount);
    DELETE_ARRAY(actual.positions);
    DELETE_ARRAY(actual.indices);
    DELETE_ARRAY(actual.glyphs);

    le_close(engine);

free_expected:
    le_fontClose(font);
}

//int LynxMain()
int main()
{
	/*LEUnicode ucharsT1[]={0x0C2E,0x0C46,0x0C30,0x0C3E,0x0C2E,0x0C3F,0x0C15,0x0C4D,0x0020,0x0C1C,0x0C32,0x0C3E,0x0C02,0x0C24,0x0C30,0x0C4D,0x0C17,0x0C24,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C41,0x0020,0x0C2F,0x0C41,0x0C28,0x0C48,0x0C1F,0x0C46,0x0C21,0x0C4D,0x0020,0x0C38,0x0C4D,0x0C1F,0x0C47,0x0C1F,0x0C4D,0x0C38,0x0C4D,0x200C,0x0020,0x0C32,0x0C4B,0x0C28,0x0C3F,0x0020,0x0C38,0x0C46,0x0C2F,0x0C3F,0x0C02,0x0C1F,0x0C4D,0x0020,0x0C32,0x0C42,0x0C2F,0x0C3F,0x0C38,0x0C4D,0x0020,0x0C2A,0x0C1F,0x0C4D,0x0C1F,0x0C23,0x0C2E,0x0C41,0x0020,0x0C24,0x0C42,0x0C30,0x0C4D,0x0C2A,0x0C41,0x0C28,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0020,0x0C2E,0x0C3F,0x0C38,0x0C4D,0x0C38,0x0C4B,0x0C30,0x0C40,0x0020,0x0C28,0x0C26,0x0C3F,0x0020,0x0C15,0x0C3F,0x0C02,0x0C26,0x0C3F,0x0020,0x0C2D,0x0C3E,0x0C17,0x0C2E,0x0C41,0x0C32,0x0C4B,0x0020,0x0C0F,0x0C30,0x0C4D,0x0C2A,0x0C21,0x0C3F,0x0C28,0x0020,0x0C05,0x0C26,0x0C4D,0x0C2D,0x0C41,0x0C24,0x0C2E,0x0C48,0x0C28,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C41,0x002E,0x0020,0x0C07,0x0C35,0x0C3F,0x0020,0x0C32,0x0C48,0x0C2E,0x0C4D,0x0020,0x0C38,0x0C4D,0x0C1F,0x0C4B,0x0C28,0x0C4D,0x0C38,0x0C4D,0x0028,0x0C38,0x0C41,0x0C28,0x0C4D,0x0C28,0x0C2A,0x0C41,0x0C30,0x0C3E,0x0C2F,0x0C3F,0x0029,0x0020,0x0C28,0x0C40,0x0C1F,0x0C3F,0x0020,0x0C15,0x0C32,0x0C2F,0x0C3F,0x0C15,0x0020,0x0C35,0x0C32,0x0C28,0x0020,0x0C2D,0x0C42,0x0020,0x0C05,0x0C02,0x0C24,0x0C30,0x0C4D,0x0C2D,0x0C3E,0x0C17,0x0C2E,0x0C41,0x0C32,0x0C4B,0x0020,0x0C30,0x0C42,0x0C2A,0x0C41,0x0020,0x0C26,0x0C3F,0x0C26,0x0C4D,0x0C26,0x0C41,0x0C15,0x0C41,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0C2F,0x0C3F,0x002E,0x0020,0x0C05,0x0C28,0x0C47,0x0C15,0x0020,0x0C35,0x0C47,0x0C32,0x0020,0x0C38,0x0C02,0x0C35,0x0C24,0x0C4D,0x0C38,0x0C30,0x0C3E,0x0C32,0x0020,0x0C28,0x0C41,0x0C02,0x0C21,0x0C3F,0x0020,0x0C35,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C3E,0x0C30,0x0C2E,0x0C48,0x0C28,0x0020,0x0C38,0x0C41,0x0C28,0x0C4D,0x0C28,0x0C2A,0x0C41,0x0C30,0x0C3E,0x0C2F,0x0C3F,0x0020,0x0C28,0x0C3F,0x0C32,0x0C41,0x0C35,0x0C32,0x0020,0x0C2E,0x0C40,0x0C26,0x0020,0x0C2A,0x0C4D,0x0C30,0x0C35,0x0C39,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C41,0x0C28,0x0C4D,0x0C28,0x0020,0x0C2E,0x0C3F,0x0C38,0x0C4D,0x0C38,0x0C4B,0x0C30,0x0C40,0x0020,0x0C28,0x0C26,0x0C3F,0x0020,0x0C15,0x0C3E,0x0C30,0x0C23,0x0C02,0x0C17,0x0C3E,0x0020,0x0C05,0x0C26,0x0C4D,0x0C2D,0x0C41,0x0C24,0x0020,0x0C1C,0x0C32,0x0C3E,0x0C02,0x0C24,0x0C30,0x0C4D,0x0C17,0x0C24,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C41,0x0020,0x0C30,0x0C42,0x0C2A,0x0C41,0x0020,0x0C26,0x0C3F,0x0C26,0x0C4D,0x0C26,0x0C41,0x0C15,0x0C41,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0C2F,0x0C3F,0x002E,0x0020,0x0C08,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C4D,0x0C32,0x0C4B,0x0020,0x0C15,0x0C4A,0x0C32,0x0C02,0x0C2C,0x0C38,0x0C4D,0x200C,0x0C15,0x0C41,0x0020,0x0C2A,0x0C42,0x0C30,0x0C4D,0x0C35,0x0C2A,0x0C41,0x0020,0x0C38,0x0C4D,0x0C25,0x0C3E,0x0C28,0x0C3F,0x0C15,0x0020,0x0C05,0x0C2E,0x0C46,0x0C30,0x0C3F,0x0C15,0x0C28,0x0C4D,0x0020,0x0C05,0x0C35,0x0C36,0x0C47,0x0C37,0x0C3E,0x0C32,0x0C41,0x0020,0x0C15,0x0C28,0x0C41,0x0C17,0x0C4A,0x0C28,0x0C2C,0x0C21,0x0C4D,0x0C21,0x0C3E,0x0C2F,0x0C3F,0x002E,0x0020,0x0C2A,0x0C4D,0x0C30,0x0C38,0x0C4D,0x0C24,0x0C41,0x0C24,0x0C2E,0x0C41,0x0020,0x0C07,0x0C35,0x0C3F,0x0020,0x0C38,0x0C46,0x0C2F,0x0C3F,0x0C02,0x0C1F,0x0C4D,0x0020,0x0C32,0x0C42,0x0C2F,0x0C3F,0x0C38,0x0C4D,0x0020,0x0C2A,0x0C1F,0x0C4D,0x0C1F,0x0C23,0x0020,0x0C2A,0x0C4D,0x0C30,0x0C24,0x0C4D,0x0C2F,0x0C47,0x0C15,0x0020,0x0C2A,0x0C30,0x0C4D,0x0C2F,0x0C1F,0x0C15,0x0020,0x0C06,0x0C15,0x0C30,0x0C4D,0x0C37,0x0C23,0x0C32,0x0C32,0x0C4B,0x0020,0x0C2A,0x0C4D,0x0C30,0x0C27,0x0C3E,0x0C28,0x0C2E,0x0C48,0x0C28,0x0C35,0x0C3F,0x002E,0x0020,0x0C2F,0x0C41,0x0020,0x0C0E,0x0C38,0x0C4D,0x0020,0x0C39,0x0C48,0x0C35,0x0C47,0x0020,0x0036,0x0036,0x0020,0x0C2A,0x0C4D,0x0C30,0x0C27,0x0C3E,0x0C28,0x0020,0x0C06,0x0C15,0x0C30,0x0C4D,0x0C37,0x0C23,0x0C32,0x0C32,0x0C4B,0x0020,0x0C07,0x0C26,0x0C3F,0x0020,0x0C12,0x0C15,0x0C1F,0x0C3F,0x002E,0x0020,0x0C26,0x0C40,0x0C28,0x0C3F,0x0C28,0x0C3F,0x0020,0x0C38,0x0C02,0x0C35,0x0C24,0x0C4D,0x0C38,0x0C30,0x0C3E,0x0C28,0x0C3F,0x0C15,0x0C3F,0x0020,0x0031,0x002C,0x0035,0x0030,0x002C,0x0030,0x0030,0x0030,0x0020,0x0C2E,0x0C02,0x0C26,0x0C3F,0x0020,0x0C38,0x0C02,0x0C26,0x0C30,0x0C4D,0x0C36,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C41,0x0C02,0x0C1F,0x0C3E,0x0C30,0x0C28,0x0C3F,0x0020,0x0C05,0x0C02,0x0C1A,0x0C28,0x0C3E,0x002E,0x0020,0x0C2F,0x0C41,0x002E,0x0C0E,0x0C38,0x0C4D,0x002E,0x0C0E,0x002E,0x0020,0x0C2C,0x0C3E,0x0C2C,0x0C4D,0x0020,0x0C15,0x0C47,0x0C35,0x0C4D,0x0020,0x0C15,0x0C3E,0x0C2E,0x0C4D,0x0020,0x0C08,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C28,0x0C41,0x0020,0x0C05,0x0C2E,0x0C46,0x0C30,0x0C3F,0x0C15,0x0C3E,0x0C32,0x0C4B,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0020,0x0C2A,0x0C4A,0x0C21,0x0C35,0x0C48,0x0C28,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C32,0x0C4B,0x0020,0x0031,0x0037,0x0031,0x0C35,0x0020,0x0C36,0x0C4D,0x0C30,0x0C47,0x0C23,0x0C3F,0x0C32,0x0C4B,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C32,0x0C41,0x0020,0x0C17,0x0C41,0x0C30,0x0C4D,0x0C24,0x0C3F,0x0C02,0x0C1A,0x0C3E,0x0C30,0x0C41,0x002E,0x0C2E,0x0C46,0x0C30,0x0C3E,0x0C2E,0x0C3F,0x0C15,0x0C4D,0x0020,0x0C15,0x0C47,0x0C35,0x0C30,0x0C4D,0x0C28,0x0C4D,0x0020,0x0C17,0x0C41,0x0C39,0x0C32,0x0C41,0x0020,0x0034,0x0030,0x0030,0x0020,0x0C35,0x0C47,0x0C32,0x0020,0x0C38,0x0C02,0x0C35,0x0C24,0x0C4D,0x0C38,0x0C30,0x0C3E,0x0C32,0x0020,0x0C28,0x0C41,0x0C02,0x0C21,0x0C3F,0x0020,0x0C1A,0x0C3F,0x0C28,0x0C4D,0x0C28,0x0C17,0x0C3E,0x0020,0x0C38,0x0C41,0x0C28,0x0C4D,0x0C28,0x0C2A,0x0C41,0x0C30,0x0C3E,0x0C2F,0x0C3F,0x0020,0x0C28,0x0C3F,0x0C32,0x0C41,0x0C35,0x0C32,0x0020,0x0C15,0x0C3E,0x0C30,0x0C23,0x0C02,0x0C17,0x0C3E,0x0020,0x0C30,0x0C42,0x0C2A,0x0C41,0x0020,0x0C26,0x0C3F,0x0C26,0x0C4D,0x0C26,0x0C41,0x0C15,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C32,0x0C41,0x0020,0x0C2A,0x0C30,0x0C3F,0x0C36,0x0C40,0x0C32,0x0C15,0x0C41,0x0C32,0x0020,0x0C2D,0x0C3E,0x0C35,0x0C28,0x002E,0x0020,0x0C36,0x0C24,0x0C3E,0x0C2C,0x0C4D,0x0C26,0x0C3E,0x0C32,0x0020,0x0C2E,0x0C41,0x0C02,0x0C26,0x0C41,0x0020,0x0C15,0x0C3E,0x0C32,0x0C2E,0x0C41,0x0C32,0x0C4B,0x0020,0x0C38,0x0C4D,0x0C25,0x0C3E,0x0C28,0x0C3F,0x0C15,0x0020,0x0C05,0x0C2E,0x0C46,0x0C30,0x0C3F,0x0C15,0x0C28,0x0C4D,0x0C32,0x0C41,0x0020,0x0C35,0x0C40,0x0C1F,0x0C3F,0x0C28,0x0C3F,0x0020,0x0C28,0x0C3F,0x0C35,0x0C3E,0x0C38,0x0C3E,0x0C30,0x0C4D,0x0C25,0x0C2E,0x0C41,0x0020,0x0C09,0x0C2A,0x0C2F,0x0C4B,0x0C17,0x0C3F,0x0C02,0x0C1A,0x0C3E,0x0C30,0x0C41,0x002E,0x0020,0x0C2E,0x0C4A,0x0C26,0x0C1F,0x0C3F,0x0020,0x0C38,0x0C3E,0x0C30,0x0C3F,0x0C17,0x0C3E,0x0020,0x0C2E,0x0C3F,0x0C38,0x0C3F,0x0C38,0x0C3F,0x0C2A,0x0C3F,0x0020,0x0C28,0x0C26,0x0C3F,0x0020,0x0C2A,0x0C36,0x0C4D,0x0C1A,0x0C3F,0x0C2E,0x0020,0x0C24,0x0C40,0x0C30,0x0C2E,0x0C41,0x0C32,0x0C4B,0x0020,0x0C10,0x0C30,0x0C4B,0x0C2A,0x0C3E,0x0020,0x0C35,0x0C3E,0x0C30,0x0C41,0x0020,0x0C26,0x0C40,0x0C28,0x0C3F,0x0C28,0x0C3F,0x0020,0x0C17,0x0C41,0x0C30,0x0C4D,0x0C24,0x0C3F,0x0C02,0x0C1A,0x0C3E,0x0C30,0x0C41,0x002E};*/
	
	LEUnicode ucharsT1[]={'1','2','A','B','C',' ',0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												0xc13,0xc02,0x20,0xc28,0xc2e,0xc03,0x20,0xc36,0xc3f,0xc35,0xc3e,0xc2f,0xc03,0x20,
												}; 
//	LEUnicode ucharsT[]={'1','2','A','B','C',' ','G','o','w','r','e','e',' ',0x0C0E,0x0C15,0x0C4D,0x0C15,0x0C21,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0020,0x0C2A,0x0C15,0x0C4D,0x0C15,0x0C28,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C47,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F,0x0020,0x0C1A,0x0C46,0x0C32,0x0C3F,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C05,0x0C32,0x0C4D,0x0C32,0x0C3E,0x0C30,0x0C40,0x000D,0x000A,0x0C28,0x0C3E,0x0020,0x0C28,0x0C40,0x0C26,0x0C48,0x0C28,0x0C3E,0x0020,0x0C06,0x0C15,0x0C4D,0x0C1A,0x0C02,0x0020,0x0C28,0x0C40,0x0C32,0x0C3E,0x0020,0x0C15,0x0C28,0x0C3F,0x0C2A,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C42,0x0020,0x0C09,0x0C02,0x0C26,0x0C3F,0x0020,0x0C05,0x0C30,0x0C46,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C17,0x0C3E,0x0C30,0x0C21,0x0C3F,0x0C08,0x000D,0x000A,0x0C28,0x0C47,0x0C28,0x0C41,0x0020,0x0C15,0x0C42,0x0C21,0x0C3E,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C3E,0x0C2F,0x0C3E,0x0C28,0x0C3E,0x0020,
		//0x0C0E,0x0C15,0x0C4D,0x0C15,0x0C21,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0020,0x0C2A,0x0C15,0x0C4D,0x0C15,0x0C28,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C47,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F,0x0020,0x0C1A,0x0C46,0x0C32,0x0C3F,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C05,0x0C32,0x0C4D,0x0C32,0x0C3E,0x0C30,0x0C40,0x000D,0x000A,0x0C28,0x0C3E,0x0020,0x0C28,0x0C40,0x0C26,0x0C48,0x0C28,0x0C3E,0x0020,0x0C06,0x0C15,0x0C4D,0x0C1A,0x0C02,0x0020,0x0C28,0x0C40,0x0C32,0x0C3E,0x0020,0x0C15,0x0C28,0x0C3F,0x0C2A,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C42,0x0020,0x0C09,0x0C02,0x0C26,0x0C3F,0x0020,0x0C05,0x0C30,0x0C46,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C17,0x0C3E,0x0C30,0x0C21,0x0C3F,0x0C08,0x000D,0x000A,0x0C28,0x0C47,0x0C28,0x0C41,0x0020,0x0C15,0x0C42,0x0C21,0x0C3E,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C3E,0x0C2F,0x0C3E,0x0C28,0x0C3E,0x0020,
		//0x0C0E,0x0C15,0x0C4D,0x0C15,0x0C21,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C3E,0x0020,0x0C2A,0x0C15,0x0C4D,0x0C15,0x0C28,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C47,0x0020,0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F,0x0020,0x0C1A,0x0C46,0x0C32,0x0C3F,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C05,0x0C32,0x0C4D,0x0C32,0x0C3E,0x0C30,0x0C40,0x000D,0x000A,0x0C28,0x0C3E,0x0020,0x0C28,0x0C40,0x0C26,0x0C48,0x0C28,0x0C3E,0x0020,0x0C06,0x0C15,0x0C4D,0x0C1A,0x0C02,0x0020,0x0C28,0x0C40,0x0C32,0x0C3E,0x0020,0x0C15,0x0C28,0x0C3F,0x0C2A,0x0C3F,0x0C38,0x0C4D,0x0C24,0x0C42,0x0020,0x0C09,0x0C02,0x0C26,0x0C3F,0x0020,0x0C05,0x0C30,0x0C46,0x0020,0x0C07,0x0C26,0x0C47,0x0C02,0x0020,0x0C17,0x0C3E,0x0C30,0x0C21,0x0C3F,0x0C08,0x000D,0x000A,0x0C28,0x0C47,0x0C28,0x0C41,0x0020,0x0C15,0x0C42,0x0C21,0x0C3E,0x0020,0x0C28,0x0C41,0x0C35,0x0C4D,0x0C35,0x0C3E,0x0C2F,0x0C3E,0x0C28,0x0C3E,0x0020};
//	LEUnicode uchars[]={0x0C09,0x0C28,0x0C4D,0x0C28,0x0C1F,0x0C4D,0x0C1F,0x0C41,0x0C02,0x0C1F,0x0C41,0x0C02,0x0C26,0x0C3F};
	//LEUnicode ucharsK[]={'1','2','A','B','C',' ','G','o','w','r','e','e',' ',0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,
		//				0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,
		//				0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD,0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD };
	//LEUnicode ucharsK[]={'1','2','A','B','C',' ','G','o','w','r','e','e',' ',0x0C8F, 0x0C92, 0x0CB3, 0x0CC1, 0x0C9F, 0x0CC6, 0x0020, 0x0CB8, 0x0CBF, 0x0CB8, 0x0CCD, 0x0C9F, 0x0CAE, 0x0CCD, 0x0CB8, 0x0CCD};
	
	//LEUnicode ucharsK1[]={'1','2','A','B','C',' ','G','o','w','r','e','e',' ',0xCB6, 0xCCD, 0xCB0, 0xCC0, 0xCA8, 0xCBF,'?',':','#',0xcb8,0xccd,0xca4,0xccd,0xcb0,0xcc0,0x20,0xcb8,0xc82,0xcb5,0xca5,0xccd,0xcb8,0xcb0,0xc82, '@', '!', 0xca4, 0xccd, 0xcb0, 0xcbf, 0xcb8, 0xcc2, 0xcb2, 0xc82};
	//LEUnicode ucharsTam[]={'1','2','A','B','C',' ','G','o','w','r','e','e',' ',0xBA4, 0xBA9, 0xBC1, 0xBB7, 0xBCD};
	//LEUnicode ucharsHindi[]={'1','2','A','B','C',' ','G','o','w','r','e','e',' ',0x924, 0x94d, 0x930, 0x93f, 0x936, 0x942, 0x932, 0x902, 0x20, 0x936, 0x93e, 0x902, 0x924, 0x93f, 0x20, 0x913, 0x92e, 0x20, 0x928, 0x92e, 0x903 };
	LEUnicode ucharsSep[]={'*','*','*','*','*','*','*','*','*','*','*','*','*','*'};
	int charCount;
	
	charCount = sizeof (ucharsT1)/sizeof (ucharsT1[0]);

	FindChars(ucharsT1,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);


	printf ("Entered\n");

	
	//charCount = sizeof (ucharsK)/sizeof (ucharsK[0]);

//	FindChars(ucharsK,charCount,FontFile[KANNADA_LANGUAGE],KANNADA_LANGUAGE);

	printf ("Entered %d\n",__LINE__);

	charCount = sizeof (ucharsSep)/sizeof (ucharsSep[0]);

	FindChars(ucharsSep,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	/*
	printf ("Entered %d\n",__LINE__);
	charCount = sizeof (ucharsK1)/sizeof (ucharsK[0]);

	FindChars(ucharsK1,charCount,FontFile[KANNADA_LANGUAGE],KANNADA_LANGUAGE);
	printf ("Entered %d\n",__LINE__);

	charCount = sizeof (ucharsSep)/sizeof (ucharsSep[0]);

	FindChars(ucharsSep,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	printf ("Entered %d\n",__LINE__);

	charCount = sizeof (ucharsTam)/sizeof (ucharsTam[0]);

	FindChars(ucharsTam,charCount,FontFile[TAMIL_LANGUAGE],TAMIL_LANGUAGE);
	printf ("Entered %d\n",__LINE__);

	charCount = sizeof (ucharsSep)/sizeof (ucharsSep[0]);

	FindChars(ucharsSep,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);

	printf ("Entered %d\n",__LINE__);
	charCount = sizeof (ucharsHindi)/sizeof (ucharsHindi[0]);

	FindChars(ucharsHindi,charCount,FontFile[HINDI_LANGUAGE],HINDI_LANGUAGE); 
	printf ("Entered %d\n",__LINE__);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	charCount = sizeof (ucharsT)/sizeof (ucharsT[0]);

	FindChars(ucharsT,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);

	printf ("Entered %d\n",__LINE__);
	charCount = sizeof (ucharsSep)/sizeof (ucharsSep[0]);

	FindChars(ucharsSep,charCount,FontFile[TELUGU_LANGUAGE],TELUGU_LANGUAGE);
	printf ("Entered %d\n",__LINE__);

*/
}
